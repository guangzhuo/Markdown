**重要思想：在运行时才能实现最小、一致地订阅子集**

问：Mobx如何有效地将所有衍生保持在一个一致地状态？

> 答：不缓存数据，在需要时重新计算。Mobx认为这是很高效地，因为Mobx不会计算所有衍生，只会计算确保参与反应的计算。这被称为响应式地。

问：没有参与反应的衍生呢？

> 答：如果一个衍生没有被激活，它将被按需处理。就像一个普通的getter函数一样，懒衍生如果没有用了，将被简单的垃圾回收。所有computed需要使用纯函数，因为对于纯函数而言，是懒衍生还是直接使用并不重要，在相同的状态下，总是返回相同的结果。

问：当状态变化时，衍生是如何计算的？

> 答：当重新计算被触发时，衍生函数将被压入到衍生堆栈中。只要计算正在运行，每个被访问的状态都会将自身注册为衍生堆栈最顶层函数的依赖项。当计算值被需要了，如果该值已经处于reactive状态，则该值可以简单最后已知的值，否则它将push自己到衍生堆栈中，切换到reactive模式并开始计算，：

具体计算过程如下:

> 可观察值像所有观察者发送过时通知，表明它已经变得陈旧。任何受影响的衍生将以递归的
方式将通知传递给其观察者。因此，依赖关系树的一部分将被标记为陈旧。


> 在发送陈旧通知并存储新值后，一个就绪通知将被发送，用于指示该值是否确实发生了变化


> 一旦衍生收到步骤1中每个陈旧通知的就绪通知，它就会知道所有的被观察值都稳定了，于是将
开始重新计算。计算就绪和陈旧消息的数量可以确保这一点。


> 如果没有就绪通知指出一个值变化了，衍生将直接告诉自己的观察者它已经准备好了且没有变
化中的值


同步执行
Mobx同步运行所有内容。这有2大好处：

> 不可能观察陈旧的衍生
追踪堆栈和调试变得简单

> Mobx还提供事务机制。事务推迟所有就绪通知，直到事务块执行完成后，同步运行和更新所有内容。


# 对比Redux

1. Redux将数据保存在单一store中，Mobx将数据保存在分散的多个store中
2. Redux需要手动处理变化后的操作，Mobx使用observable保存数据，数据变化后自动处理响应的操作
3. Redux使用不可变状态，不能直接去修改它，而是应该使用纯函数返回一个新的状态；Mobx中的状态是可以直接修改的
