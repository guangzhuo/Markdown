> React对Virtual DOM树进行 分层比较、层级控制，只对相同颜色框内的节点进行比较(同一父节点的全部子节点)，当发现某一子节点不在了直接删除该节点以及其所有子节点，不会用于进一步的比较，在算法层面上就是说只需要遍历一次就可以了，而无需在进行不必要的比较，便能完成整个DOM树的比较。



1. 同层比较（无text无children）
2. 同层比较（有text无children）
3. 节点比较（无text有children）
4. key值比较（节点位移保留节点）

### React的diff策略

1. 策略一：忽略Web UI中DOM节点跨层级移动；
2. 策略二：拥有相同类型的两个组件产生的DOM结构也是相似的，不同类型的两个组件产生的DOM结构则不近相同
3. 策略三：对于同一层级的一组子节点，通过分配唯一唯一id进行区分（key值）
 在Web UI的场景下，基于以上三个点，React对tree diff、component diff、element diff进行优化，将普适diff的复杂度降低到一个数量级，保证了整体UI界面的构建性能！


### 三个优化

> tree diff

基于策略一，React的做法是把dom tree分层级，对于两个dom tree只比较同一层次的节点，忽略Dom中节点跨层级移动操作，只对同一个父节点下的所有的子节点进行比较。如果对比发现该父节点不存在则直接删除该节点下所有子节点，不会做进一步比较，这样只需要对dom tree进行一次遍历就完成了两个tree的比较。
==那么对于跨层级的dom操作是怎么进行处理的呢？==下面通过一个图例进行阐述

![image](http://user-gold-cdn.xitu.io/2018/4/3/1628b06256b89434?imageslim)

两个tree进行对比，右边的新tree发现A节点已经没有了，则会直接销毁A以及下面的子节点B、C；在D节点上面发现多了一个A节点，则会重新创建一个新的A节点以及相应的子节点。
具体的操作顺序：create A → create B → creact C → delete A。

#### 优化建议


```
保证稳定dom结构有利于提升性能，不建议频繁真正的移除或者添加节点
```

> component diff

React应用是基于组件构建的，对于组件的比较优化侧重于以下几点：
1. 同一类型组件遵从tree diff比较v-dom树
2. 不通类型组件，先将该组件归类为dirty component，替换下整个组件下的所有子节点
3. 同一类型组件Virtual Dom没有变化，React允许开发者使用shouldComponentUpdate（）来判断该组件是否进行diff，运用得当可以节省diff计算时间，提升性能

![image](http://user-gold-cdn.xitu.io/2018/4/3/1628b065cfcfda4b?imageslim)

如上图，当组件D → 组件G时，diff判断为不同类型的组件，虽然它们的结构相似甚至一样，diff仍然不会比较二者结构，会直接销毁D及其子节点，然后新建一个G相关的子tree，这显然会影响性能，官方虽然认定这种情况极少出现，但是开发中的这种现象造成的影响是非常大的。

#### 优化建议


```
对于同一类型组件合理使用shouldComponentUpdate（），应该避免结构相同类型不同的组件
```

> element diff

对于同一层级的element节点，diff提供了以下3种节点操作：
1. 	INSERT_MARKUP 插入节点：对全新节点执行节点插入操作
2. MOVE_EXISING 移动节点：组件新集合中有组件旧集合中的类型，且element可更新，即组件调用了receiveComponent，这时可以复用之前的dom，执行dom移动操作
3. REMOVE_NODE 移除节点：此时有两种情况：组件新集合中有组件旧集合中的类型，但对应的element不可更新、旧组建不在新集合里面，这两种情况需要执行节点删除操作

![image](http://user-gold-cdn.xitu.io/2018/4/3/1628b069a9c69b9b?imageslim)

一般diff在比较集合[A,B,C,D]和[B，A，D，C]的时候会进行全部对比，即按对应位置逐个比较，发现每个位置对应的元素都有所更新，则把旧集合全部移除，替换成新的集合，如上图，但是这样的操作在React中显然是复杂、低效、影响性能的操作，因为新集合中所有的元素都可以进行复用，无需删除重新创建，耗费性能和内存，只需要移动元素位置即可。
React对这一现象做出了一个高效的策略：允许开发者对同一层级的同组子节点添加唯一key值进行区分。意义就是代码上的一小步，性能上的一大步，甚至是翻天覆地的变化！


#### 优化建议


```
在开发过程中，同层级的节点添加唯一key值可以极大提升性能，尽量减少将最后一个节点移动到列表首部的操作，当节点达到一定的数量以后或者操作过于频繁，在一定程度上会影响React的渲染性能。比如大量节点拖拽排序的问题。
```
